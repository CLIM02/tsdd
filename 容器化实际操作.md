# Docker 化策略：多阶段构建（Multi-Stage Build）

处理 Monorepo 和前端/Node.js 项目的最佳实践是使用多阶段构建。这能确保您的最终镜像体积最小，并且不包含任何开发或构建依赖（如 node_modules、turbo 等）。

# dockerfile 编写 
```
# ====================================================================
# 第一阶段：构建阶段 (Builder Stage) - 用于安装依赖和执行构建命令
# ====================================================================
FROM node:20-alpine AS builder

# 设置工作目录
WORKDIR /app

# 1. 复制 Monorepo 根目录下的关键文件
# 注意：这里我们只复制必要的文件以利用 Docker 缓存。
COPY package.json yarn.lock ./
COPY turbo.json ./

# 2. 复制 apps 和 packages 目录，但只复制您服务需要的子项目
# 实际操作中，您应该只复制当前服务相关的 apps/* 和 packages/* 目录
# 复制整个 Monorepo（如果项目规模允许）
COPY apps apps
COPY packages packages

# 3. 安装依赖 (使用 --frozen-lockfile 确保构建可重复)
# 如果您使用了 Yarn Berry (PnP)，命令会有所不同
RUN yarn install --frozen-lockfile

# 4. 执行构建命令 (Turbo 会并行处理所有需要的构建任务)
# 假设您的 Web/后端应用在 apps/my-api-app
RUN yarn build
# 针对单个应用执行构建，这取决于您的 turbo 配置
# RUN turbo run build --filter=my-api-app...

# ====================================================================
# 第二阶段：运行阶段 (Production Stage) - 最终、精简的运行时镜像
# ====================================================================
# 使用更小的基础镜像，例如 Node.js Slim 或 Alpine
FROM node:20-alpine AS runner

# 设置工作目录
WORKDIR /app

# 1. 复制运行时所需的文件
# 从构建阶段复制 Monorepo 根目录下的 package.json 和 yarn.lock
COPY --from=builder /app/package.json /app/yarn.lock ./

# 2. 复制生产环境所需的 node_modules
# 注意：这一步是关键，它只复制生产依赖和 .pnp 文件（如果使用 PnP）
RUN yarn install --production --frozen-lockfile

# 3. 复制特定应用的构建产物和运行代码
# 假设您的服务是 apps/my-api-app
COPY --from=builder /app/apps/my-api-app/dist ./dist
# 复制服务入口文件（如果不在 dist 中）
COPY --from=builder /app/apps/my-api-app/server.js ./server.js

# 4. 暴露您的服务端口 (例如 3000)
# 这适用于您的 HTTP/WebSocket/SSE 服务
EXPOSE 3000

# 5. 定义容器启动命令
CMD [ "node", "server.js" ]

# --------------------------------------------------------------------
# 额外提示：如果您的服务入口文件是 apps/my-api-app/dist/main.js
# CMD [ "node", "dist/main.js" ]
# --------------------------------------------------------------------
```

创建 .dockerignore 在项目根目录
```
排除所有 node_modules
node_modules
**/node_modules

排除缓存和日志
.turbo
.next
.git
.DS_Store
npm-debug.log*
yarn-debug.log*
yarn-error.log*
logs
*.log

# 排除构建产物目录
dist
build

```

# 运行容器 
```
docker run -d -p 8080:3000 --name tsdd-container my-tsdd-service:latest

```

# WebSocket/SSE 注意事项
```
端口暴露: 确保 EXPOSE 的端口与您的服务监听的端口一致，并且在 docker run 时正确映射。

反向代理 (Nginx/Load Balancer): 如果您在 Docker 前使用 Nginx 或其他负载均衡器来处理流量，请确保它们正确配置了支持 WebSocket 协议所需的升级头 (Connection: Upgrade 和 Upgrade: websocket)。否则，WebSocket 连接会失败。对于 HTTP 和 SSE，通常不需要特殊配置，但 WebSocket 是必需的。

心跳和超时: 确保您的服务和代理的超时设置足够长，以适应 WebSocket 和 SSE 这种长连接模式。

```


# HTTPS 和 CDN 的容器化策略

```
组件	作用	部署位置
负载均衡器 (LBs)	在云服务商 (AWS ELB, GCP Load Balancer, Azure App Gateway) 层面，这是最推荐的做法。	在 Docker 外部 (云服务商基础设施)
反向代理 (Nginx/Traefik)	如果您在自己的服务器上部署 Docker，可以使用这些代理容器来终止 HTTPS。	在 Docker 内部 (作为单独的容器，位于您的应用容器之前)

```

```
应用容器 (tsdd-app): 监听 HTTP 端口（例如 3000）。

代理容器 (nginx/traefik): 监听 HTTPS 端口（443）。它拥有证书，负责解密 HTTPS 流量，然后将解密后的 HTTP 流量转发给您的 tsdd-app 容器的 3000 端口。

证书管理: 使用 Let's Encrypt 结合 Certbot/Traefik 的自动功能来获取和更新证书。
```